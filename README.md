# DB_PyQt
## Geekbrains_DB_PyQt

## Урок 1. Полезные модули
### Task Lesson 1
1. Написать функцию host_ping(), в которой с помощью утилиты ping будет проверяться доступность сетевых узлов. 
Аргументом функции является список, в котором каждый сетевой узел должен быть представлен именем хоста или ip-адресом.
В функции необходимо перебирать ip-адреса и проверять их доступность с выводом 
соответствующего сообщения («Узел доступен», «Узел недоступен»). 
При этом ip-адрес сетевого узла должен создаваться с помощью функции ip_address(). 
(Внимание! Аргументом сабпроцеса должен быть список, а не строка!!! Крайне желательно использование потоков.)
2. Написать функцию host_range_ping() (возможности которой основаны на функции из примера 1) для перебора ip-адресов 
из заданного диапазона. Меняться должен только последний октет каждого адреса. 
По результатам проверки должно выводиться соответствующее сообщение.
3. Написать функцию host_range_ping_tab(), возможности которой основаны на функции из примера 2. 
Но в данном случае результат должен быть итоговым по всем ip-адресам, представленным 
в табличном формате (использовать модуль tabulate). Таблица должна состоять из двух колонок и выглядеть примерно так:
Reachable

10.0.0.1
10.0.0.2
Unreachable

10.0.0.3
10.0.0.4

## Урок 2. Дескрипторы и метаклассы.
### Task Lesson 2

1. Реализовать метакласс ClientVerifier, выполняющий базовую проверку класса «Клиент» 
(для некоторых проверок уместно использовать модуль dis):
* отсутствие вызовов accept и listen для сокетов;
* использование сокетов для работы по TCP;

2. Реализовать метакласс ServerVerifier, выполняющий базовую проверку класса «Сервер»:
* отсутствие вызовов connect для сокетов;
* использование сокетов для работы по TCP.
3. Реализовать дескриптор для класса серверного сокета, 
а в нем — проверку номера порта. Это должно быть целое число (>=0). 
Значение порта по умолчанию равняется 7777. 
Дескриптор надо создать в отдельном классе. Его экземпляр добавить в пределах класса серверного сокета. 
Номер порта передается в экземпляр дескриптора при запуске сервера.

## Урок 3. Хранение данных в БД. ORM SQLAlchemy
### Task Lesson 3
1. Начать реализацию класса «Хранилище» для серверной стороны. Хранение необходимо осуществлять в базе данных. 
2. В качестве СУБД использовать sqlite. Для взаимодействия с БД можно применять ORM.

Опорная схема базы данных:
На стороне сервера БД содержит следующие таблицы:
a) клиент:
* логин;
* информация.
b) история клиента:
* время входа;
* ip-адрес.
c) список активных пользователей:
* id клиента;
* адрес:
* port;
* login_time.


## Урок 4. Хранение данных в БД (продолжение) и основы Qt
### Task Lesson 4
1. Продолжить реализацию класса хранилища для серверной стороны.

a) Реализовать функционал работы со списком контактов по протоколу JIM:
    Получение списка контактов
    Запрос к серверу:
    {
    "action": "get_contacts",
    "time": <unix timestamp>,
    "user_login": "login"
    }

Положительный ответ сервера будет содержать список контактов:
    {
    "response": "202",
    "alert": "[‘nick_1’, ‘nick_2’,...]"
    }
Получение списка контактов — не самая частая операция при взаимодействии с сервером. Она должна выполняться после 
подключения и авторизации клиента. Инициируется им же. В процессе получения списка контактов клиент не должен 
инициировать другие запросы.
Добавление/удаление контакта в список контактов
Запрос к серверу:
    {
    "action": "add_contact" | "del_contact",
    "user_id": "nickname",
    "time": <unix timestamp>,
    "user_login": "login"
    }

Ответ сервера будет содержать одно сообщение с кодом результата и необязательной расшифровкой:
    {
    "response": xxx,
    }
b) Реализовать хранение информации в БД на стороне клиента:
* список контактов;
* история сообщений.
Реализовать графический интерфейс для мессенджера, используя библиотеку PyQt. Реализовать графический интерфейс 
администратора сервера:
* отображение списка всех клиентов;
* отображение статистики клиентов;
* настройка сервера (подключение к БД, идентификация).

## Урок 5. Qt (продолжение), Qt и потоки.
### Task Lesson 5
Продолжаем работать над мессенджером:
1. Реализовать графический интерфейс пользователя на стороне клиента:
    Отображение списка контактов;
    Выбор чата двойным кликом на элементе списка контактов;
    Добавление нового контакта в локальный список контактов;
    Отображение сообщений в окне чата;
    Набор сообщения в окне ввода сообщения;
    Отправка введенного сообщения.

## Урок 6. Безопасность
### Task Lesson 6
1. Реализовать аутентификацию пользователей на сервере.
2. *Реализовать декоратор @login_required, проверяющий авторизованность пользователя 
для выполнения той или иной функции.
3. Реализовать хранение паролей в БД сервера (пароли не хранятся в открытом виде — хранится хэш-образ 
от пароля с добавлением криптографической соли).
4. *Реализовать возможность сквозного шифрования сообщений (использовать асимметричный шифр, 
ключи которого хранятся только у клиентов).


## Урок 7. PEP-8, подготовка документации.
### Task Lesson 7
1. Для проекта «Мессенджер» подготовить документацию с использованием sphinx-doc.
2. Проверить программный код домашних заданий текущего курса и курса Python-1 на соответствие положениям PEP-8. 
При необходимости выполнить преобразования.

## Урок 8. Подготовка дистрибутива
### Task Lesson 8
1. Для разработанного проекта «Мессенджер» сформировать whl-пакеты с дистрибутивами сервера и клиента.
2. *Выполнить процедуру сборки созданного проекта «Мессенджер» с помощью утилиты cx_Freeze.
3. Выполнить загрузку сформированных whl-пакетов с дистрибутивами сервера и клиента в репозиторий сервиса PyPi 
и прислать ссылки на эти пакеты (а не ссылку на репозиторий!)
4. *В качестве защиты курсового проекта необходимо записать в любой удобной для вас программе видеоролик 
5. (скринкаст) продолжительностью 1-5 минут. Представьте, что вам необходимо презентовать вашу работу заказчику 
или аудитории. В скринкасте расскажите о вашем проекте, продемонстрируйте его возможности и функционал. 
Ссылку на видео приложите к практическому заданию, например, в комментарии к уроку. И не забудьте открыть 
доступ на просмотр! :) Видеопрезентация продукта развивает у вас дополнительные мягкие навыки и является 
обязательной для засчитывания курсового проекта.
